# Описание команд кисти

Описывается известная информация об управлении роботизированной кистью на основании собранных данных и проекта управления на Python.

На данный момент кисть представляет установку, которая может управляться тремя контроллерами. Введем термины: **верхний контроллер** - отвечает за разгибание пальцев установки, **нижний контроллер** - отвечает за сгибание пальцев установки, **задний контроллер** - отвечает за ротацию руки по углам.

Верхний и нижний контроллер управляют тросами, которые сгибают и разгибают пальцы, при этом при затягивании троссов нижнего контроллера должны растягиваться пропорционально троссы верхнего контроллера для сгибания пальцев и наоборот. Оба контроллера могут выполнять операции движение влево (закручивание?), движение вправо (раскручивание?), остановку и фиксацию троссов в текущем положении. Задний котроллер умеет поворачивать установку на заданный примерный угол за счет команд: поворот влево, поворот вправо, зафиксировать и расслабление. 

Для всех контроллеров определены свои COM-порты, они подключаются проводом USB type-c в три разьема. Именования подключенных устройств не определено, поэтому нужно самостоятельно определять, какой из контроллеров подключен к существующему активному COM-порту в списке.

Для работы с COM-портом верхнего или нижнего контроллера в проекте управления Python определен следующий класс ComportInstance с заданными параметрами.

```mermaid
classDiagram
class ComportInstance {
  +baudrate int = 115200
  +bytesize = 8
  +parity = 'N' 
  +stopbits  = 1
  +timeout = 2.0
  +port 
  +last_time
  +last_delay
  +open_comport() открывает и reset in-out-буферы
  +close_comport() reset in-out-буферы и закрывает
  +write_comport(data)
  +send_com(config, power_byte, motor_byte, pwm_byte, time_int, delay)
  +send_adc(config_byte, adc_int)
}
```

Команды управления верхним и нижним контроллерами указаны в классе CommandMaster.
* PWM - ШИМ - сигнал для управления можностью
* ADC - АЦП - аналогово-цифровой преобразователь - что считывает? I - сила тока, в каких попугаях?

```mermaid
classDiagram
class CommandMaster{
   + time_limited_motion(config, power_byte, motor_byte, pwm_byte, time_int, delay) просто переводит из вещественного времени в целое значение, где **проверка на 100?**
   + upper_comport ComportInstance верхний контроллер (троссы наверху пальца?)
   + lower_comport ComportInstance нижний контроллер (троссы снизу пальца?)
   + upper_commands_list выполненные команды
   + lower_commands_list выполненные команды
   + set_upper_comport() - установка upper_comport
   + set_lower_comport() - установка lower_comport
   + upper_send_adc(config_byte, adc_int) - отправка команды send_adc из config_byte 00100000 (поднят (5) бит) с нужным значением adc_int, где указан номер пальцев в поднятых битах
   + get_upper_commands_list() получение upper_commands_list
   + __add_command_to_upper_list (command) добавление наверно в upper_commands_list байтов команды с их переводом в 16-ричное представление?
   + clear_upper_command_list очищает upper_commands_list
   + send_command(part, config, power_byte, motor_byte, pwm_byte, time_int, delay) - запускает выполнения команды (с вещественным временем), забивает команду с помощью __add_command_to_upper_list, part - верх/низ
   + stop_command(config, motor_byte) наверно, останавливает - config='00000010'
   + power_command(part, config, power_byte) запуск на исполнение config='00000001', power_byte='00000001'
   + send_command_bytes( part, data) - отправка команд в байтовом представлении
   + release_upper_comport_after_thread() - закрывает и открывает ComportInstance (ЧЕЕЕ?)
}
```
На основании указанного кода можно выделить следующие параметры команд.

| название | описание | допустимые значения | бит конфигурации | аналогия |
| -- | -- | -- | -- | -- | 
| config | Конфигурация | - | 0-5 бит поднимаются под команды ниже (где 0 - младший бит, справа налево), 1 - присутствует параметр в запросе, 0 - отсутствует, 6,7 - не задействованы | заполнение пакета битами, количество поднятых бит == количеству байт в пакете без учета текущего байта |
| power_byte | исполнение команды ? | (0) | 1/0 | а если 0 - то что и зачем? |
| motor_byte | Номер двигателя и команда вращения | (1) | 0-2 бита - номер мотора 0 до 4, 3-4 бита - (0 - стоп, 1 - вправо, 2 **-вправо?**, 3 - удержание) - что закручивает, а что раскручивает? | раскручивание и скручивание тросса за заданное время |
| pwm_byte | ШИМ | (2) | от 0 до 100 - какие попугаи? | скорость расручивания и закручивания троссов |
| time_int | Время работы | (3) | от 0 до 100, где 1 == 0.1 с |  |
| delay | Задержка исполнения команды | (4) | от 0 до 100, где 1 == 0.1 с |  |
|  adc_int  | Разрешение АЦП | (5) | поднятые биты моторов 0 до 4 бит для каждого пальца | получение измерений на АЦП? |

Направление пальцев в моторах должно быть:
* 0 - большой 
* 1 - указательный
* 2 - средний
* 3 - безымяннй
* 4 - мизинец
*Но "Что надоходится в файлах - lower_finger и lower_rotation???"*

ШИМ отвечает за скорость раскручивания и закручивания тросика на пальце, а номер двигателя и команда вращения выполнения действия с заданной задержкой и временем выполнения.
Время time_int включает delay или общее время - это delay+time_int?

Насколько понимаю, может отправляться набор команд, которые накапливаются и исполняются по команде POWER?
Команда POWER может применяться к конкретному мотору?
Можно ли сочетать команду изменения ШИМа с ротацией? Да.
Можно ли сочетать команду POWER с изменением ШИМа и ротацией? 
Можно ли сочетать команды изменения ШИМа и ротации с ADC? 
Что будет, если в стеке будет и команда поворота и команда удержания в одном стеке?
Зачем для проверки (check) ротации используется установка ШИМа?
И почему при проверке пальца используется установка ШИМа на 15? В чем отличие провеки пальца от проверки ротации?
Send ADC - работает?

Итого можно:
* замерить ADC
* изменить ШИМ
* изменить вращение по загручиванию и раскручиванию троса
* запустить выполнение

Как было сказано ранее, если тросс один закручивается, то противоположный тросс на другом констроллере должен раскручиваться. И в классе ManualControl следующие описания для решения этой задачи:

```mermaid
classDiagram
class ManualControl{
   + get_upper_opposite_pwm(low_pwm) = 7 - видно угол противоположной скорости вращения??? почему 7?
   + get_opposite_time_delay(original_time, original_delay) - original_time * 0.8, а original_delay * 1.1 - почему такие цифры???
   + opposite_pwm_from_adc(adc_data) расчет pwm по значению АЦП и линейного уравнения
}
```

Формула линейного уравнения на данный момент:
```math
y = (((yMin - yMax) * (x - xMax)) / (xMin - xMax)) + y0
```
$xMax = 0.15$

$xMin = 0.04$

$yMax = 7$

$yMin = 90$

где y - значение ШИМ, а x - (I) - сила тока?

Почему y0 = 7 максимальный, а y1 = 90 минимальный? 

Для вращения пальца нужно передать параметры с противоположными значениями? 


Команда sendADC - какая структура пакета?
Для получения нового пакета нужно передать новое значение sendADC?

* 20 байт
```
$y[k] = (x[i - 1] + x[i] * 256) * 3.3 / 4096
i+=2, k++
+ ema_convertion
```

* 40 байт (both?)
```
$y[k] = x[i] * 3.3 / 4096
i++, k++
ema_convertion(data)
```

Обработка:
```
ema_convertion(data)
alpha = 0.01
alpha * data[i] + (1 - alpha) * result[-1]
result - последнее значение. ФНЧ что-ли? 
```

Какая частота данных в пакетах sendADC?
```
byte_count = int(upper_time * 50)
```

Как остановить sendADC? Отправить все биты опущенными?



